# 归并排序算法分析

1. [算法思路](#算法思想)
2. [算法实现方法](#算法实现方法)

## 算法思路

### 如何看待无序组
归并算法的基本思路是通过合并一个个有序组完成排序。那么，我们遇到的第一个问题是初始的无序
组怎么变成有序组呢？  
这里，我的思路是将长度为n的无序组，视作n个长度为1的有序组，这里是基于一个事实：最短的有序
组长度是1，最短的无序组长度是2。因此，我们天然的可以将它视作n个长度为1的有序组.  
接下来，只需要对它们进行一次次的归并就可以完成排序了。  

### 如何合并
我们先思考如何将两个相邻的有序组完成归并，这里我的思路是用两个索引分别指向第一与第二个组，
设组一与组二的长度分别是n1与n2，在第一次比较中会得到最终结果中的最小值***[P1]***。那么
，接下来，如果能保证剩下总长度为(n1+n2-1)的两个组还是有序的，那么我们是不是可以重复以
上过程，得到全局第K小的元素（K是比较的次数），最终完成合并。  

>P1:，因为，它们分别是两个组中的最小者，因此，全局最小者一定是二者中的较小者。我们通过比
较就可以找这个最小者，

## 算法实现方法

### 实现归并的第一个问题是什么呢
通过上面的思路分析，我们可以模糊的认识到对无序组中的有序组不断进行合并，我们每次要合并的
组的长度呈2的次幂递增,那么，第一个问题就是在什么时候可以停止合并呢？我的答案是当合并组的
长度大于等于初始无序组时（不保证是最佳答案哈）

### 如何实现比较后，剩余两组依然有序
我们合并的思路中，最关键的操作是保证剩余两组有序，这样，我们就可以不断重复比较剩余两组来
完成合并了。  
这里，我们分别用fi和si指向组一和组二，然后进行比较，会有两种情况：  
fi小于或等于si，此时，fi时较小者，因此，我们只需要fi+1就可以了。  
fi大于si,此时，si是较小着，那么，我们是不是应该较将si指向的元素放在fi的位置上，那么，怎么
放呢？因为我们要保证剩下二组是有序组，所以，我们并不能直接交换它们。这里，我的解决方案是
从si开是依次于前一个元素进行交换，直到与fi发生交换为止，这样做既可以将si处的元素放在原来
fi的位置，同时也能保证剩余二组是有序的。 

*感谢阅读，文章如有错误，望指正，万分感谢*
